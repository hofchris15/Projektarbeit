%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterstart
\section{Kurzfassung}
\label{section:kurzfassung}
\paragraph{Kurzfassung}
In dieser Arbeit wurde mit Hilfe des Perfect Frameworks ein Webserver auf einem Ubuntu Server 16.04 LTS erstellt. Zur Erstellung wurde die Programmiersprache Swift in der Version 3.1.1 verwendet, welches open-source für die Verwendung mit Linux zur Verfügung steht. Der implementierte Server wurde mit einem Webserver auf Basis von Express.js Frameworks verglichen. Zur Dokumentation des Projektes wurde ein WikiBook erstellt, welches beschreibt wie man allgemein einen Webserver mit Swift auf Linux erstellt.
\paragraph[{Abstract}
In this work a webserver on the basis of the Perfect Framework was implemented. As programming language, open source Swift at version 3.1.1 was used for the implementation. The Webserver runs on a Ubuntu Server 16.04 LTS. Further, the implementation was compared to anthor implementation of the same server based on the Express.js Framework. As the documentation of the project a wikibook was produced, which details the step to creating a web server with swift on a Linux mashin. 
% Einleitung
\section{Einleitung}
\label{sec:einleitung}
Das Ziel dieser Arbeit ist es einen Webserver mit Hilfe der Programmiersprache Swift auf einem Linux-Server zu entwickeln. 
\subsection{Swift}
\label{subsection:swift}
Swift ist die noch junge Programmiersprache von Apple, welche als Nachfolger von Objective-C gedacht ist. Die Sprache ist objektorientiert, stark typisiert, mit Typinfernce, mutliparadigmen-orientierte, kompilierende, all zwecks Programmiersprache. Die Frameworks Cocoa und Cocoa Touch funktionieren mit Swift und Brücken zu Objective-C sind in die Sprache integriert. Der Swift-Code selbst soll dabei präzise und doch gleichzeitig ausdrucksstark sein\parencite{appleswift}.  Die Programmiersprache wurde auf der WWDC (Apple's World Wide Developer Conference)\parencite{swiftannounced} enthüllt. Swift wurde über Jahre hinweg produziert und wird immer noch weiterentwickelt. Zur Zeit ist Swift auf Version 4\parencite{ swift4}. Im \textit{TIOBE Index}\parencite[][Stand Juli 2017]{tiobe} liegt Swift auf Platz 12 hinter Go (Platz 10) und Perl (Platz 11), aber vor Ruby (Platz 13). Auch ist dem Index zu entnehmen, dass sich Swift um zwei Plätze verbessert hat. In der \textit{Developer Survey} von stackoverflow schafft es Swift auf Platz 11 der meist benutzen Programmiersprachen und im Ranking der Beliebtesten sogar auf Platz 4 vor Go und Python\parencite{survey2017}. Im Jahr zuvor war Swift bei der Beliebtheit sogar auf Platz 2\parencite{survey2016}. Besonders die Verwendbarkeit von Swift für alle Arten von Projekten, von iOS Development, über systemnahe Programmierung, mobile Apps, bis hin zu Cloud Technologien, sorgen für eine hohe Beliebtheit. Genauso wie die Sicherheit von Swift, wie durch automatische Speicherverwaltung, Array Indexes werden auf out-of-bound Zugriffe geprüft, Optionals erzwingen die Behandlung von möglichen nil-Werten und Variablen sind immer initialisiert. Andererseits scheinen bestimmte Teile der Programmiersprache wie Closures, Error-Handling und Optional gerade Einsteigern das Erlernen von Swift zu erschweren\parencite{studyonswift}.
\paragraph{Basics of Swift}
\label{para:basicsofswift}
Um die Sprache zu verstehen, beziehungsweiße um die Erlernbarkeit zu beurteilen folgt nun eine kleine Einführung basierend auf \textit{The Swift Programming Language}\parencite{swiftbook}.
Swift kennt Konstanten und Variablen, wobei durch eine Doppelpunkt getrennt der Typ annotiert wird. Wenn möglich kann der Typ auch inferiert werden.
\lstset{
	caption=Variablen und Konstanten,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
	var : String = „Swift“  // Ein String
	var = „FH-Joanneum“  // Auch ein String durch Typinferenz
 	let = „Linux“  // Eine Konstante
	var x = 0, y = 1, z = 3  // Mehrere Variablen in einer Zeile
\end{lstlisting}
Als nächstes Kollektionen. Swift kennt Array, Set, Dictionary. Diese sind standardmäßig „mutable“, das heißt änderbar, wird aber die Kollektion als \lstinline{let} sprich Konstante initialisiert, wird sie unveränderbar.
\lstset{
	caption=Array, Set, Dictionary,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
var intarray = [Int]()   // Ein Array aus Integern
var stringarray = [„Bier“, „Wein“, 
	„Wasser“] // Array bereits mit Werten gefüllt
let anotherone = [Int]()	// Immutable Array
var intset = Set<Int>()	// Ein Set, der Typ muss hashbar sein
var dictionary = [Int: String]()  // Ein Dictionary mit einem Key (Int) Value(String) Paar
\end{lstlisting}
Der Kontrollfluss wird in Swift ähnlich zu anderen Sprachen geregelt. Swift kennt \lstinline{for}, \lstinline{while}, \lstinline{if} und \lstinline{switch}.
\swiftcode
\begin{lstlisting}
let demo = [„Eins“, „Zwei“, „Drei“, „Vier“]
// Ein for-Loop
for number in demo {
	print(„Nummer = \(number)!“) // print() schreibt in die Konsole
} 
// Ausgabe
// Nummer = Eins!
// Nummer = Zwei!
// Nummer = Drei!
// Nummer = Vier!
var  counter = 0
var max = 2
// Ein while-Loop
while counter < max {
	print( „Der Zähler ist \(counter)“)
	counter = counter + 1
} 
// Ausgabe
// Der Zähler ist 0
// Der Zähler ist 1

// repeat while
repeat {
	print( „Der Zähler ist \(counter)“)
} while counter > 0 
// Ausgabe
// Der Zähler ist 1
// Der Zähler ist 0

var age = 19
// If Abfragen
if age >= 18 { // Eine Altersabfrage
   print(„Hier ist ein Bier“) 
   // Über 18 bekommt man Bier
} else {
  print („Hier ist ein Glass mit Wasser“) 
  // Unter 18 ein Glass Wasser
}

let char: Character = „F“
// Switch Case
switch char {
    case „A“:
	// Hier ist der Code für A
    case „B“, „C“:
	// Hier ist der Code für B und C
    case „F“:
	print(„Der Code von F“)
	fallthrough 
	// Der nachfolgende Case wird auch ausgeführt
    case „D“:
	print(„Der Code von D“)
    default:
	// Wenn nichts passt
} 
// Ausgabe
// Der Code von F
// Der Code von D

// Label und break
outer: while true { // while-Loop mit Label
	for i in 0..<100 { // Würde von 0 bis 99 zählen
		print(„Index \(i)“)
		break outer 
		// Bricht beide Loops und springt zum Label
	}
} 
// Ausgabe
// Index 0
\end{lstlisting} 
Funktionen in Swift bestehen aus Funktionsname, Parameter (eventuell mit Label) und Rückgabewert. Funktionen haben nur einen Rückgabewert, dieser kann aber ein Optional sein, bzw. können Funktionen auch Fehler werfen.
\lstset{
	caption=Funktionen,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
// Eine Funktion die einen String als Parameter bekommt
// und einen String zurück gibt
// „sag“ ist das Label des Parameters
// „name“ ist der Name der Variable
func einefunktion(sag name: String) → String {
	print(„Name = \(name)“)
	return „Ein String als Rückgabewert“
}
// Aufruf
einefunktion(sag: „Bert“)
// Ausgabe (der Rückgabewert wird hier ignoriert)
// Name = Bert


// Mit _ kann das Label beim Aufruf unterdrückt werden
// Void als Rückgabewert bedeutet kein Rückgabewert
func keinlabel(_ name: String) → Void {
	print(„Name = \(name)“)
}
// Aufruf
keinlabel(„Hugo“) 	// Name = Hugo
einefunktion(sag: „Hugo“) // Name = Hugo

// In-Out Parameters erlaubt Parameter in der
// Funktion zu ändern, sofern 
//diese keine Konstanten sind
func wechseldich(wechsel name: inout String) {
	name = „Bob“
}
// Aufruf
var name = „Billy“
print(name) // Billy
wechseldich(wechsel: name)
print(name) // Bob
\end{lstlisting}

Der nächste Punkt ist Closures, diese entsprechen in etwa Lambda-Ausdrücken. Diese erlauben Callback-Funktionen direkt inline zu definieren.
\lstset{
	caption=Closures,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
// Diese Funktion benötigt eine Callback Funktion
func function(callback: (String)→Void) {
	callback(„Gruß von der Funktion“)
}
// Und hier der Aufruf mittels Closure
function(callback: { s in print(s) }) // Gruß von der Funktion
// Oder in der Trailing-Variante
function(callback: (String) → Void ) {
	s in print(„Trailing \(s)“)
}
\end{lstlisting}
Vor den Klassen und  Strukturen noch eine schnelle Einführung in  Enumerations.
\lstset{
	caption=Enumerations,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
// Hier eine Enumeration mit komplexerm Typ
enum FHEntity {
    case student(nr: Int, name: String) 
    case lehrender(name: String)
}

var std = FHEntity.student(nr: 13, name: "Geheim") 
// Lege einen neuen Studenten an

switch std {
    case .student(let nr, let name):
        print("\(name)") // Student
    case .lehrender(let name):
        print("\(name)") // Lehrender
} // Ausgabe Geheim
\end{lstlisting}
Und nun zu Strukturen und Klassen in Swift. Klassen können mehr als Strukturen und zwar Vererbung, Type-Casting, Deinitialisierung und ARC. Werden Klassen einer neuen Variable zu geordnet, wird nur die Referenz übertragen, bei Strukturen wird eine Kopie erstellt.
\lstset{
	caption=Klassen und Strukturen,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
// Eine einfache Klasse
class A {
    var name: String
    init(_ name: String) {
        self.name = name
    }
}
// Eine Einfache Struktur
struct B {
    var name: String
    init(_ name: String) {
        self.name = name
    }
}
var a = A("Montag") // neue Instanz der Klasse A
var b = B("Jänner") // neue Struktur B
var newera = a // nur Referenz
var newerb = b // neue Struktur mit kopierten Werten
newera.name = "Dienstag" // neuer Name für die Klasse
newerb.name = "Februar" // neuer Name für die Struktur
print("Die alte Klasse ist \(a.name) " +
       "die neue ist \(newera.name)")
print("Die alte Struktur ist \(b.name) " +
        "die neue ist \(newerb.name)")
// Die alte Klasse war Dienstag die neue ist Dienstag
// Die alte Struktur war Jänner die neue ist Februar
\end{lstlisting}
Die Funktionen einer Klasse sind vom Syntax her leicht anders als in anderen Programmiersprachen, aber dafür sehr intuitiv. 
\lstset{
	caption=Wie funktionieren Klassen,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
// Eine Klasse mit zur Veranschaulichung 
class SomeClass {
	lazy data = Data() // lazy initialisiert erst bei der ersten Nutzung
	var name: String
	var value: Int {
		get { // Der Getter
			return 42 * 12 // Kalkuliert diesen Wert bei der Rückgabe.
		}
		set(newValue) { // Der Setter, würde auch ohne newValue gehen
			self.value = newValue
		}	
	} 

	// „Mutating“ sorgt dafür, dass die Funktion 
	// die Membervariablen direkt setzten darf.
	mutating func newSomeclass(data: Data, name: String) {
		self.name = name
		self.data  = data
	}
	class func klassenfunktion() {
		// Klassen Funktionen sind wie statische Funktionen in 
		// anderen Programmiersprachen und kann vererbt werden, 
		// bei Strukturen wird static als Schlüsselwort verwendet
	}

	deinit {
		// Die Instanz wird zerstört
	}
}

// Vererbung wir mit „:“ ermöglicht
class SomeSubClass: SomeClass {
	// Sub class of SomeClass
	// Mit dem Schlüsselwort override werden 
	// Funktionen der Eltern überschrieben
}
\end{lstlisting}
Nun zum ARC, der Speicherverwaltung von Swift. Bei ARC werden die Referenzen gezählt die auf ein Objekt zeigen und erst wenn es keine Referenzen mehr gibt wird die Instanz gelöscht. Memoryleaks können in Swift dann entstehen wenn zwei Instanzen gegenseitig Referenzen auf einenander haben. Um dieses Problem zu lösen wird das Schlüsselwort \lstinline{weak} verwendet.
\lstset{
	caption=Speicherverwaltung mit 'weak',
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
class Auto {
    // Das Schlüsselwort weak, sorgt dafür,
    // dass der Motor deinitialisiert, sobald
    // nur noch schwache (weak) Referenzen auf
    // ihn zeigen
    weak var motor: Motor? 
    // Jedes Auto hat einen Motor
    
    init(motor: Motor) {
        self.motor = motor
        self.motor!.auto = self
    }
    deinit { print("Das Auto wurde zerlegt")}
}
class Motor {
    var auto: Auto? 
    // Jeder Motor gehört zu einem Auto
    
    init() {}
    deinit { print("Der Motor wurde zerlegt")}
}

// neue Instanzen initialisieren
var v6: Motor? = Motor()
var porsche: Auto? = Auto(motor: v6!)

porsche = nil // Noch hält Motor eine starke Referenz

v6 = nil // Nun hält nur noch Auto eine schwache Referenz
// v6 wird deinitialisiert
// damit gibt es keine Referenz auf porsche
// und porsche wird deinitialisiert

// Ausgabe
// Der Motor wurde zerlegt
// Das Auto wurde zerlegt
\end{lstlisting}
Das zweite Feature von Swift mit dem Einsteiger Probleme haben, sind Optionale und die Verkettung von Optionalen. Dabei handelt es lediglich um Variablen oder Konstanten die auch \lstinline{nil} sein können, dass heißt sie können auch ein Rückgabewert sein. Um an den wahren Wert der Variable zu kommen, muss diese ausgewickelt (unwrapped) werden. Dies geschieht durch „?“ oder „!“. 
\lstset{
	caption=Optionale und Verkettung,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
var a: Int? 	// Optional welches Int oder nil sein kann
var b: Int! 	// Auch ein Optional, jedoch wickelt sich dieses automatisch aus

// Aufruf mit Optional Verkettung
if let var = a?.max { // a muss mit ? ausgewickelt werden, b nicht
	// Kann .max aufgerufen werden
} else {
	// a ist nil
}

// Optionale erlauben einen Defaultwert anzugeben
var c: Int?
c = a ?? 42 //  c hat den Wert von a oder wenn a nil ist 42

// Wird mit ! ausgewickelt, macht der Entwickler ein Versprechen,
// dass das Optional nicht nil ist
var d = c! // Dank dem Defaultwert von oben, ist c nie nil
\end{lstlisting}
Zum Schluss zum basis Wissen über Swift noch Fehlerbehandlung (error handling). Fehler in Swift sind einfach Enumerationen. Funktionen, welche Fehler werfen können werden mit \lstinline{throws} deklariert. Um die Funktion auszuführen kann ein do-try-catch-Block, try? oder try! verwendet werden.
\lstset{
	caption=Fehlerbehandlung,
	label=lst:swiftworkaround,
	language=swift,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{keyword}\bfseries,
	stringstyle=\color{darkgreen},
	commentstyle=\color{darkgray},
}
\begin{lstlisting}
// Ein Fehler in Swift
enum TutorialError : Error { case KnownError }
func schlecht() throws -> String { 
// throws erlaubt der Funktion einen Fehler zu werfen
    throw TutorialError.KnownError // throw wirft den Fehler
}
// do-try-catch-Block um Fehler zu fangen
defer {
    // Der Code im defer-Block wird am Ende ausgeführt
    // egal ob try funktioniert oder ein Fehler auftritt
}
do {
    try schlecht()
} catch TutorialError.KnownError {
    // Der Fehler wird gefangen und der Code hier ausgeführt.
}
// Mit try? wird Code ausgeführt, tritt
// jedoch ein Fehler auf wird nil zurückgegeben
var text: String? = try? schlecht() // Durch den Fehler wird text = nil

// try! lässt sich Code wie try? Ohne do-try-catch-Block ausführen
// bei einem Fehler kommt es, aber zum Absturz 
\end{lstlisting}
Damit währen die Grundzüge der Programmiersprache erklärt. Jedoch gibt’s einen wichtigen Aspekt von Swift der die Sprache für diese Arbeit erst interessant  macht.
\paragraph{Swift ist Open-Source}
\label{para:swiftistopensource}
Swift ist seit Dezember 2015 unter der Apache-2.0-Lizenz verfügbar\parencite{swiftorg}. Damit ist Entwicklung von Programmen auf Linux Rechnern mit Swift möglich. In dieser Arbeit beschäftigen wir uns im Speziellen mit Implementierung eines Webservers.  Dabei stehen einige Frameworks zur Verfügen, auf die im Teil Stand der Technik genauer eingegangen wird.
% State of the Art
\section{State of the Art}
\label{sec:stateoftheart}
Das Ziel der Erstellung eines Webservers auf einer Linux-Maschine mittels der Programmiersprache Swift erfordert eine Erhebung des Stands der Technik. Als erstes wurde erhoben welche Frameworks für die Implementierung eines Swift Webserver zur Verfügung stehen. Durch Nachforschung konnten die folgenden Webframeworks für Swift auf Linux gefunden werden:  Perfect\parencite{perfect}, Vapor\parencite{vapor}, Kitura\parencite{kitura}, Zewo\parencite{zewo}, Swifter\parencite{swifter}. Die Frameworks Zewo und Vapor laufen dabei unter der MIT Lizenz, während Perfect unter der apache, beziehungsweise Kitura unter der apache2 Lizenz zur Verfügung stehen. Alle Frameworks haben eine aktive und angerschierte Gemeinschaft von Entwicklern, welche meist über die Kommunikationsdienste Slack und Gitter, beziehungsweise Email erreicht werden können. Es folgen einige Kurzfassungen der Frameworks. 
\paragraph{Frameworks}
\label{para:frameworks}
\subparagraph{Zewo}
\label{para:zewo}
Zewo ist ein leichtgewichtiges Framework. Die Entwickler wurden durch die Programmiersprache Go inspiriert um ähnliche Nebenläufigkeit in mittels \lstinline{libmil}  zu erreichen. Durch die Einführung von Go-artigen \textit{"communicating sequential processes"} versuchen die Entwickler von Zewo die Menge der oft schwere lesbaren Ketten von Callback-Funktionen zu reduzieren. Interessant ist auch, dass das Projekt sehr Modular aufgebaut ist.  Auch haben die Entwickler von Zewo ihr Routing als Baumstruktur implementiert, die das Routing noch schneller machen soll. Als Nachteil muss gesagt werden, dass der Code oft nicht Kommentiert wurde und so sehr umständlich nach den richtigen Funktionen gesucht werden muss. Am Ende sollte zu Zewo noch gesagt werden, dass die Entwickler sich mit dem Vapor-Framework \ref{para:vapor} auf einen Http-Standard für Open-Source Swift geeinigt haben, der über https://github.com/open-swift/S4 abgerufen werden kann\parencite{openswifthttp}. Dies macht den Code zwischen Vapor und Zewo austauschbar. 
\subparagraph{Swifter}
\label{para:swifter}
Swifter ist ein absolut minimaler Http-Server. Mit der Entwicklung von Swifter wurde begonnen, bevor Swift Open-Source wurde. Das minimalistische Framework kann Dateien aus Ordnern teilen, statische HTML-Seiten ausliefern und WebSockets erstellen. Einerseits fehlen Dokumentation und API, andererseits sind durch die Beispiele auf der Projektseite auf GitHub alle Anwendungsmöglichkeiten abgedeckt. 
\subparagraph{Swifton}
\label{para:swifton}
Als kleine Anmerkung hier ist Swifton (Kofferwort aus: Swift on Rails). Hierbei handelt es sich um ein auf Zewo (\ref{para:zewo}) basierendes Webframework welches stark von Ruby on Rails inspiriert wurde. Das Projekt wird aber zur Zeit nicht aktiv weiterentwickelt, da die Entwickler durch die stark statische Art von Swift das Projekt zu sehr eingeschränkt sehen\parencite{swifton}.
\subparagraph{Kitura}
\label{para:kitura}
Kitura ist ein Webframework von IBM und ein damit verbundenes starkes Entwicklerteam. Kitura unterstützt unteranderm Middleware, SSL/TLS und FastCGI. Dieses Framework ist in der Verwendung ähnlich zu Express.js und verwendet wieder Callback-Funktonen. Kitura funktioniert mit Cloud-Plattformen wie Bluemix und ist dabei autoskalierbar. IBM investiert stark in Open-Source Swift mit Workshops auf WWDC\parencite{WWDC}, Präsentationen, Video-Einführungen\parencite{ibmdemo} und online Kursen auf Plattformen wie Udemy\parencite{udemyswift}. Populären Blogs wie \textit{raywenderlich.com} und \textit{stormpath.com}  zufolge ist das Ziel von IBM Java als Enterprise-Sprache durch Swift abzulösen und Kitura ist Teil dieser Unternehmung.\parencite{rayenterprise}\parencite{stormswiftserver} Zur API ist zusagen, dass die wichtigsten Referenzen vorhanden und dokumentiert sind.
\subparagraph{Vapor}
\label{para:vapor}
Vapor ist mit Entstehungsdatum July 2016 eines der Ältesten der hier genannten Frameworks und wahrscheinlich das Älteste mit der Absicht Linux zu verwenden. Es unterstützt WebSockets. TLS, Trusted Encryption und BCrypt Hashes werden standardmäßig verwendet. Die API ist sehr ausführlich, wenn nicht sogar komplett, jedoch wie der Code selbst nicht vollständig dokumentiert, im Gegensatz zu Kitura\ref{para:kitura} wo die API nur das Nötigste enthält, aber dafür gut Dokumentiert ist. Wie bei Zewo \ref{para:zewo} erwähnt gibt es einen Http-Standard auf den sich die Autoren geeinigt haben (https://github.com/open-swift/S4). Dies macht den Code von Vapor mit Zewo austauschbar. Vapor scheint das Einsteiger freundlichste der hier genannten Frameworks zu sein.
\subparagraph{Perfect}
\label{para:perfect}
Perfect verfolgt die Philosophie, Swift als fundamentale Programmiersprache zu verwenden, also Apps und Server in Swift programmieren. Dazu gibt Perfect volle Xcode Unterstützung für Entwicklung und Debugging. Perfect stellt Werkzeuge für mehr als nur für einen Webserver zur Verfügung, wie Datenbankenunterstützung, JSON-Bearbeitung, Streaming (Kafka Module), Message Queue (Mosquitto), Secure Sockets Encryption, SMTP, XML, Logging und viele mehr. Diese Menge an zusätzlichen Werkzeugen und das schnell robuste Framework spielen wahrscheinlich eine Rolle, weshalb Perfect auf GitHub das beliebteste Framework für Server-Side Swift ist (stand Juli 2017).
\chapterend
