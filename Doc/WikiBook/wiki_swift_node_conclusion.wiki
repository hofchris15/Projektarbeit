==Installation von Swift==

Da Swift eine Sprache die vorrängig für MacOS erstellt wurde, ist es erst mit ein wenig Aufwand auf Linux Distributionen lauffähig. Dazu muss die Toolchain von <span class="plainlinks">[https://swift.org/download/#releases Swift.org ] </span> in ein Verzeichnis geladen werden, und je nach Wunsch in der Systemumgebung definiert werden. Eine genau Installationsanleitung kann ebenfalls unter <span class = "plainlinks">[https://swift.org/getting-started/ Swift.org ]</span> nachgelesen werden. Für die Code Beispiele ist der user gegen den tatsächlichen username auszutauschen. Um dies zu vereinfachen ist der Username unseres Beispielusers "user".
Lade die aktuelle stabile Toolchain auf der Download Seite von <span class="plainlinks">[https://swift.org/download/#releases Swift.org ] </span> herunter und speicher es in einem beliebigen Verzeichnis z.B. im Downloads-Verzeichnis des aktuellen users.  
Danach muss <span class="plainlinks">[http://clang.org/ clang]</span> installiert werden, um das compilieren von Swift Programmen zu ermöglichen. Dies ist mit dem Befehl auf einer Linux Bash möglich<ref name="swiftStart">{{Internetquelle|autor=Apple Inc |jahr=2017 |titel=Getting Started |url=https://swift.org/getting-started/#installing-swift |datum=ohne Datum |zugriff=2017-07-26}} Apple Inc (2017f): Getting Started, [online] https://swift.org/getting-started/#installing-swift [27.07.2017].</ref>:

<code>sudo apt-get install clang</code>

Danach muss die heruntergeladenen Swift Toolchain in ein geeignetes Verzeichnis extrahiert werden und der PATH Variable hinzugefügt werden:
Dazu erstellen wir im ersten Schritt das Verzeichnis "install" im user Home-Verzeichnis

<code>sudo mkdir /home/user/install</code>

Entpacken der toolchain in das zuvor erstelle "install" Verzeichnis:

<code>sudo tar -xf /home/user/Downloads/swift-3.1.1-RELEASE-ubuntu16.10.tar.gz -C /home/user/install</code>

Um das ausführen von Swift leichter zu gestallten kann Swift der PATH-Variable temporär hinzugefügt werden:

<code>export PATH=${PATH}:/home/user/install/swift-3.1.1-RELEASE-ubuntu16.10/usr/bin</code>

Um dauerhaft, z.B. nach einem Neustart, Swift im Terminal zur Verfügung zu haben, kann der Pfad zur Toolchain in die Datei /etc/environment eingetragen werden.
Dazu wird die Datei environment mit einem Texteditor, in unserem Fall "VIM" geöffnet und erweitert:

<code>sudo vim /etc/environment</code>

und folgenden Text angefügen:

''''':/home/user/install/swift-3.1.1-RELEASE-ubuntu16.10/usr/bin''''' 

Danach sollte die Installation mit der Ausgabe der Version von Swift überprüft werden:

<code>swift --version</code>

welches die Ausgabe:

<code>Swift version 3.1.1 (swift-3.1.1-RELEASE)</code>

zur Folge hat. 
Eventuell muss die Besitzrechte des Swift-Installationsordner geändert werden, da eventuell Zugriffrechte nicht gegeben sind oder der root als Besitzer hinterlegt ist. Dazu wird folgender Befehl auf den Ordner angewand:<br/>
<code>sudo chown -R user:user ~/install/swift-3.1.1-RELEASE-ubuntu16.10/</code>

Damit ist die Installation abgeschlossen.

===Swift REPL===
Swift bietet bei dieser Installation ein Terminal Tool namens Swift-REPL (Swift-Read-eval-print-loop) welches es ermöglicht Swift direkt auf der Konsole zu test und auszuführen
Da dies für das ausführen des Servers nicht notwendig ist, wird hier darauf nicht näher eingegangen, dazu aber jedenfalls mehr auf <span class = "plainlinks">[https://swift.org/getting-started/ Swift.org ]</span><ref name="SwiftREPL">{{Internetquelle|autor=Apple Inc |jahr=2017c |titel=Using the REPL |url=https://swift.org/getting-started/#using-the-repl |datum=ohne Datum |zugriff=2017-07-26}} Apple Inc (2017c): Using the REPL, [online] https://swift.org/getting-started/#using-the-repl [26.07.2017].</ref>.

===Swift Package Manager===
Der Package Manager ist eine Möglichkeit ein Skelton für ein Projekt zu erstellen. Der Package Manger erstellt einen Verzeichnisbaum der eine gewisse Grundstruktur ermöglicht. Diese Struktur wird auf <span class = "plainlinks">[https://swift.org/getting-started/ Swift.org ]</span> noch in der Version 3.0 beschrieben jedoch änderte sich dies mit dem RELEASE von Version 3.1.
Zuerst wird ein Verzeichnis erstellt, dass das neue Projekt repräsentiert und in weiterer folge als Projektordner bezeichnet wird.
<blockquote>
	<code>mkdir Hello</code><br/>
	<code>cd Hello</code><br/>
	<code>swift package init</code><br/>
</blockquote>
Mit dem Ausführen des Init-Befehls wird unter anderem eine Package.swift Datei erstellt, in dem alle Abhängigkeiten des Projekt gespeichert werden. Weiter wir dein Verzeichnis Sources erstellt, in dem sich nur .swift-Datein befinden dürfen. Im Verzeichnis Tests befinden sich die Testklassen<ref name="SwiftPackageManager">{{Internetquelle|autor=Apple Inc |jahr=2017 |titel=Using the Package Manager |url=https://swift.org/getting-started/#using-the-package-manager |datum=ohne Datum |zugriff=2017-07-26}}
Apple Inc (2017d): Using the Package Manger, [online] https://swift.org/getting-started/#using-the-package-manager [26.07.2017].</ref>.

<blockquote>
├──Package.swift<br/>
├──Sources<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──Hello.swift<br/>
├──Tests<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──HelloTests<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──HelloTests.swift<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──LinuxMain.swift<br/>
</blockquote>

Sollte eine Strukturierung z.B. mit Hilfe von Ordner in Sources erfolgen, ist direkt unter dem Sources Verzeichnis ein weiteres Verzeichnis z.b. "exe" anzulegen, in dem die gewünschte Ordnerstruktur z.b. für ein MVC-Pattern erstellt werden kann. Es ist aufgrund des Compilers und der Modularität nicht möglich, mehrere Ordner oder Ordner und .swift-Dateien gemischt im Sources-Verzeichnis zu compilieren. Dies liegt daran, dass der Compiler Verzeichnisse als Module versteht und jeweils nur ein Modul erstellt werden kann. Daher ignoriert er oder compiliert entweder nur die Hello.swift oder den ersten gefunden Ordner.
====Falsche Struktur====

<blockquote>
├──Package.swift <br/>
├──Sources<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──model<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──fileHandler.swift<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──view<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──renderView.swift<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──controller<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──router.swift<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──main.swift<br/>
├──Tests<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──FileTests<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──FileHandlerTests.swift<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──-LinuxMain.swift<br/>
</blockquote>
====Richtige Struktur====

<blockquote>
├──Package.swift<br/>
├──Sources<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──exe<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──model<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──fileHandler.swift<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──view<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──renderView.swift<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──controller<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──router.swift<br/>
│&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──main.swift<br/>
├──Tests<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──FileTests<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──FileHandlerTests.swift<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──LinuxMain.swift<br/>
</blockquote>

===Swift compiling===
<ref name="AppleCompiler">{{Internetquelle|autor=Apple Inc |jahr=2017 |titel= Compiler and Standard Library|url=https://swift.org/compiler-stdlib/#compiler-architecture |datum=ohne Datum |zugriff=2017-07-26}} Apple Inc (2017e): Compiler and Standard Library, [online] https://swift.org/compiler-stdlib/#compiler-architecture [26.07.2017].</ref>
Der Swift Compiler kann mit dem Befehl

<code>swift build</code>

gestartet werden, dazu muss man sich im Projektordner befinden. Durch das aufrufen des Compilers werden die im Package.swift eingetragenen Abhängigkeiten z.B. von Github heruntergeladen und compiliert. Dabei wird das Verzeichnis ".build" erstellt in dem sich der ausführbare Code befindet. Erst danach wird der eigene produzierte Code compiliert und ebenfalls ins Verzeichnis "/.build/debug" gespeichert. Das compilieren von Abhängigkeiten erfolgt nur einmal nach dem Download oder dem Download von Aktualiesierungen. Die Packages werden im Ordnerbaum abgespeichert damit sie nicht jedesmal compilieren heruntergeladen werden müssen. In der alten Version 3.0 wurde dazu ein eignes Verzeichnis "Packages" angelegt, und die aus Github ausgecheckten Module in Form von Source Code gespeichert. Seit dem Update auf die Version 3.1 wird diese Verzeichnis "Packages" im Überverzeichnis ".build" mit abgespeichert. Auch hier ist der Source Code der Module zu finden. Der Compiler ingnoriert beim compilieren grundsätlich alle Verzeichnisse ab dem Sources-Ordner was zur Folge hat, das Swift-Datein bzw. Klassen nicht wie in bekannt andern Sprachen z.B. mit einem "import"-Befehl zur Verfügung gestellt werden müssen, sondern automatisch als eine große Swift-Datei angesehen werden.

Der Swift Compiler unterstütz die Systemsprachen von C und Objective-C was durch den Clang Importer erreicht wird. Der Clang-Importer importiert Clang-Module, die die C und Objective-C APIs auf die Swift APIs mappen, wodurch das compilieren auf Linux bewerkstelligt wird.

==Server installieren==

Der Server wird auf Github ausgecheckt und compiliert. Davor können zwei Einstellungen in der Config.swift eingestellt werden. Der Host vorab auf "localhost" eingestellt und der Port der vorab auf "3000" eingestellt ist. Das Projekt ist unter <span class = "plainlinks">[https://github.com/hofchris15/Projektarbeit.git Github/Projekt ]</span> mit Git auszuchecken oder als zip herunterladen. In diesem Repository befinden sich der Ordner NodeServer in dem der Reverenz-Server in JavaScript mit Node und Express.js geschrieben ist. Im Ordner SwiftServer befindet sich der in Swifft geschriebene Server, der für diese Installation relevant ist. Damit der Server läuft ist der Node-Server irrelevant, sodass dieser gelöscht werden kann oder ausgeführt werden kann wie im Kapitel "Installation Node Server" beschrieben ist.

===Installation mit Git===

<blockquote>
	<code>mkdir SwiftServer</code><br/>
	<code>cd SwiftServer</code><br/>
	<code>git clone https://github.com/hofchris15/Projektarbeit.git</code><br/>
	<code>swift build</code> 

	oder 

	<code>swift build --configuration release</code><br/>
</blockquote>

Mit dem ersten Befehl wird in einem beliebigen Verzeichnis der Ordner SwiftServer erstellt, der als Projektordner dient. Danach wechselt man in das Verzeichnis und checkt den Server von Github aus. Danach liegt der Server in Form von Source Code im Verzeichnis "SwiftServer" auf und kann mit dem letzten Befehl compiliert werden. Mit diesem Kommando wird ein debug compilierung durchgeführt, das für die Entwicklung benötigt wird, da mehr Informationen während der Laufzeit an den Entwickler ausgegeben werden. Um den Server jemanden außerhalb des Entwicklungsbereichs zu übergeben wird empfohlen den compiler auf den release-Modus zu stellen. Dazu wird der Befehl <code>swift build --configration release</code> ausgeführt. Je nach compiler Konfiguration wird das Produkt im Verzeichnis .build/debug/exe abgelegt oder .build/release/exe abgelegt.
Damit ist die Installation des Servers abgeschlossen und der Server kann gestartet werden. 

===Installation ohne Git===
Der Ablauf ohne Git ist geringfühgig anders als bei der Installation mit Git. Dazu wird der Server als .zip-Archiv von Github heruntergeladen und in das zuvor erstellt Verzeichnis "SwiftServer" entpackt. 

<blockquote>
	<code>mkdir SwiftServer</code><br/>
	<code>cd SwiftServer</code><br/>
	<code>sudo tar -xcf /path/to/SwiftServer.zip ./</code><br/>
	<code>swift build</code> 

	oder 

	<code>swift build --configuration release</code><br/>
</blockquote>

Danach ist die Installation auch ohne Git abgeschlossen und der Server kann gestartet werden.

==Server starten==
Der Server kann über ein Terminal gestartet werden nachdem dieser compiliert wurde siehe auch: [[Installation von Swift#Server installieren]] 
Danach kann der Server mit folgende Kommandos gestartet werden. Einzige Vorraussetzung ist, das man sich bereits mit dem Terminal im Projektordner befindet.

<code> ./.build/debug/exe <code>

oder mit 

<code>./.build/release/exe</code>

Danach sollte folgend Ausgabe auf dem Terminal angezeigt werden:

<blockquote>
	[DBG] init HTTPServer()<br/>
	[DBG] makeRoutes()<br/>
	[INFO] set config<br/>
	[INFO] Starting HTTP server on 0.0.0.0:3000<br/>
</blockquote>

Mit der letzen Zeile wird darüber informiert, dass der Server gestartet wurde und auf dem Port 3000 hört. Somit kann dieser mit einem bliebigen Browser angesteuert werden. Dazu wird in die Adressleiste <small>localhost:3000</small> eingegeben und es sollte die Login-Seite des Services angezeigt werden. 

Weiter mit einigen Details zum Server und den Packages die Verwendet werden. 

==Details zum Server==

Der Server entstand in Zusammenhang mit der Lehrveranstaltung "Projektarbeit" der FH Joanneum Kapfenberg Studienrichtung Software Design, mit dem Thema Swift on Linux. 
Dazu wurde von uns rechachiert und zwei interessante Frameworks für die Entwicklung eines Servers ausgewählt. Diese beiden Frameworks sind <span class = "plainlinks">[http://www.kitura.io/ Kitura.io ]</span> und <span class = "plainlinks">[http://perfect.org/ Perfect ]</span>.
Grundsätzlich sind beide Frameworks sehr ähnlich, wobei hierbei einige Punkte zu beachten sind <ref name="Kitura">{{Internetquelle|autor=IBM |jahr=o.J. |titel= Setting Up |url=http://www.kitura.io/en/starter/settingup.html |datum=ohne Datum |zugriff=2017-07-26}} IBM (o.J.): Setting Up, [online] http://www.kitura.io/en/starter/settingup.html [26.07.2017].</ref> <ref name="PerfectAbout">{{Internetquelle|autor=Sean Stephens, Kyle Jessup, Lucas Chang, Jonathan Guthrie|jahr=o.J.|titel=What Is Perfect |url=http://perfect.org/about.html |datum=ohne Datum|zugriff=2017-07-26}} Jessup, Kyle / Stephens, Sean / Chang, Lucas / Guthrie, Jonathan (o.J.): What Is Perfect, [online] http://perfect.org/about.html [26.07.2017].</ref>:
* Kitura ist ein Framework das von IBM erstellt wurde und auf MAC sowie auf Linux lauffähig ist. Perfect wurde von PerfectlySoft Inc. einem kleinem Startup Unternehmen, das sich auf die Entwicklung mit Swift spezialisiert hat. 
* IBM's Kitura hat einen Grundsätzliche Bibliothek die verwendet wird um einen HTTP Server umzusetzen und einige Packages um die Funktionalität zu erweitern. Perfect setzt auf das selbe Prinzip wie Kitura und hält wie auch Kitura ein Template als Startpunkt für den Server zur Verfügung. 
* Kitura ist für die Swift Versionen 3.1 entwickelt, Perfect für Swift Versionen der 3.0 Reihe. Leider gibt es für Perfect zu Swift 3.1 kein Update.
* Kitura und Perfect halten beide eine Documentation bereit, die ausführlich erscheint jedoch bei Perfect mehr Informationen bereit hielt.

Schlussendlich haben wir uns für Perfect entschieden. Gründe dafür waren, der eben erwähnte Punkt der Dokumentation, und das Perfect bereits länger auf dem Markt vorhanden ist. 
Viele Beispiel, Bibliotheken und Packages werden von PerfectlySoft auf deren Github Account gehostet: <span class = "plainlinks">[https://github.com/PerfectlySoft PerfectlySoft on Github ]</span>

===Installation von Perfect===

Auch Perfect setzt einige Packet auf Linux voraus, darunter openssl, libssl-dev und uuid-dev. Diese können sehr leicht mit 

<code> sudo apt-get install openssl libssl-dev uuid-dev</code> 

installiert werden<ref name="PerfectlySoft">{{Internetquelle|autor=Kyle Jessup et al.|jahr=2017|titel=Getting Started|url=https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide/gettingStarted.md |datum=2017-05-19|zugriff=2017-07-27}} Jessup, Kyle / Stephens, Sean / Chang, Lucas / Guthrie, Jonathan (2017a): Getting Started, [online] https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide/gettingStarted.md [27.07.2017].</ref>. 

===Perfect Template ===
Das Perfect Template wurde von uns als Ausgangspunkt der Entwicklung des HTTP Servers im MVC-Pattern gewählt. Als Reverence wurde von uns der selbe Server zuvor mit <span class = "plainlinks">[https://nodejs.org/en/  Node.js ]</span> und dem Framework <span class = "plainlinks">[http://expressjs.com/de/  Express.js ]</span> implementiert.
Das Perfect Template hält die Standard Baumstruktur des swift init-Prozesses bereit, die bereits in der [[Installation von Swift#Swift Package Manager]] vorgestellt wurde. Weiter befinden sich ein Datei names "main.swift" enthält, die die Initalisierung eines Serves bereithält. Interressant ist jedoch das in der Package.swift enhaltene Abhängigkeit <span class = "plainlinks">[https://github.com/PerfectlySoft/Perfect-HTTPServer.git ]</span>. Der Perfect-HTTPServer hat einige sehr nützliche Abhängigkeiten die auch wir im Server verwendet haben.

===Die wichtigsten Packages=== <ref name="Perfectorg">{{Internetquelle|autor=Sean Stephens, Kyle Jessup, Lucas Chang, Jonathan Guthrie|jahr=o.J.|titel=Documentation|url=https://www.perfect.org/docs/ |datum=ohne Datum|zugriff=2017-07-27}} Jessup, Kyle / Stephens, Sean / Chang, Lucas / Guthrie, Jonathan (o.J.): Documentation, [online] https://www.perfect.org/docs/ [27.07.2017].</ref>
Wie oben beschrieben sind einige Packete grunsätlich notwendig um den Server ins laufen zu bekommen. Diese Grund-Pakete sind PerfectLib COpenSSL, HTTP, HTTPServer, PerfectLib, LinuxBridge und Net.
* Foundation ist die standard Bibliothek von Swift und bietet die grunsätlichen Funktionen und Definition wie (Strings, Numbers,...) die von der Swift.org veröffentlicht wurden. https://developer.apple.com/documentation/foundation
* COpenSSL bietet verschieden Verschlüsselungstechniken und SSL/TLS Methoden zur Verfügung die auf Linux in C installiert werden (Dieses Paket wurde nicht verwendet) https://github.com/PerfectlySoft/Perfect-COpenSSL
* HTTP bietet verschiedene Strukturen und Methoden um mit http Clients zu kommunizieren. Diese Paket muss mit "import PerfectHTTP" im Projekt eingebunden werden https://github.com/PerfectlySoft/Perfect-HTTP
* HTTPServer bietet die Hauptstrukturen für HTTP 1.1 und HTTP 2 server und ist die Hauptabhängigkeit für das Projekt und muss mit "import PerfectHTTPServer" eingebunden werden https://github.com/PerfectlySoft/Perfect-HTTPServer
* PerfectLib ist das Herz des Perfect Frameworks und ist ohne nicht lauffähig. Muss ebenfalls mit "import PerfectLib" eingebunden werden. https://github.com/PerfectlySoft/Perfect
* LinuxBridge bildet die Brücke zwischen Perfect und den Linux Distriputionen https://github.com/PerfectlySoft/Perfect-LinuxBridge
* Net ist ein networking Paket welches TCP, SSL, UNIX Socket files und IO Event Handling zur Verfügung stellt. https://github.com/PerfectlySoft/Perfect-Net

===Zusätzliche Packages=== <ref name="Perfectorg" />

* Perfect-Logger und Perfect-RequestLogger sind Pakete die zum Loggen von Informationen auf die Konsole oder in ein Log File. der RequestLogger ist eine Kindklasse vom Logger und fängt durch das einbinden von Filtern alle Request und logged diese mit. https://github.com/PerfectlySoft/Perfect-RequestLogger
* Perfect-Session wurde verwendet um einen Session zu starten, verwalten und wieder zu vernichten. https://github.com/PerfectlySoft/Perfect-Session
* Perfect-Websockets bietet eine Funktionen zum Aufbauen von WebSocket-Verbindungen
* SwiftyBeaver<ref name="SwiftyBeaver">{{Internetquelle|autor=Sebastian Kreutzberger|jahr=2017|titel=AES256CBC.swift|url=https://github.com/SwiftyBeaver/AES256CBC/blob/master/Sources/AES256CBC.swift|datum=2017-07-25|zugriff=2017-07-27}} Kreutzberger, Sebastian (2017): AES256CBC.swift, [online] https://github.com/SwiftyBeaver/AES256CBC/blob/master/Sources/AES256CBC.swift [27.07.2017].</ref> bietet verschiede Verschlüsselungstechniken für Passwörter oder anderen empfindlichen Daten https://medium.com/swiftybeaver-blog/logging-in-server-side-swift-85bdecb6be80

===Wichtige Punkte der Implementierung===

====Linux====
Das Projekt soll nur auf Linux laufen deshalb wurde am Anfang folgender Code eingebunden, welcher das Betriebssystem überprüft und beendet sollte es kein Linux sein:
<blockquote>
	#if !os(Linux)<br/>
	import Glibc<br/>
	print("We are sorry this is only meant to be run on Linux")<br/>
	exit(1)<br/>
	#endif<br/>
</blockquote>

====Session Verwaltung====
Bei der Session sind verschieden Konfigurationen möglich. Zu beachten ist jedoch, dass die cookieDomain, die festgelegt werden kann, während der Entwicklung nicht festgelegt werden darf. Erst wenn der Server gehostet wird, kann die Domain angepasst werden, was jedoch nicht nötig ist, da mit das IPAddressLock und der userAgentLock eingeschalten sind.

<blockquote>
	SessionConfig.name = "mobileExtendSession" //Session name which is set as cookie<br/>
	SessionConfig.idle = 86400  // idle time set to one day<br/>
	// Optional<br/>
	//SessionConfig.cookieDomain = "localhost"<br/>
	SessionConfig.IPAddressLock = true //Session is bind to the IP address of the first request<br/>
	SessionConfig.userAgentLock = true //Session is bind to the user<br/>
</blockquote>

====JSON====
Objekte die als JSON serialisiert werden sollen, müssen von der Klasse JSONConvertibleObject erben, sowie die Methoden "setJSONValues" und "getJSONValues" müssen überschrieben bzw definiert werden. Zusätlich zu den üblichen Attributen des Objektes kommt ein Registrierungsname zum Einsatz. Dieser dient als Schlüssel für die Objektklasse und als Registrierungsschlüssel im Register der JSON-Decodable-Object Referenz. Mit diesem Schlüssel kann die Decodierung eines JSON Strings erfolgen und wird dem Objekt, dass erstellt werden soll zugeteilt.

<blockquote>
	public class Profile: JSONConvertibleObject {<br/>
	static let registerName = "profile"<br/>
	&#160;&#160;&#160;&#160;var username = ""<br/>
	&#160;&#160;&#160;&#160;var password = ""<br/>
	....<br/>
	....<br/>
	override public func setJSONValues(_ values: [String: Any]) {<br/>
	&#160;&#160;&#160;&#160;self.username = getJSONValue(named: "username", from: values, defaultValue: "")<br/>
	&#160;&#160;&#160;&#160;self.password = getJSONValue(named: "password", from: values, defaultValue: "")<br/>
	&#160;&#160;&#160;&#160;self.firstname = getJSONValue(named: "firstname", from: values, defaultValue: "")<br/>
	....<br/>
	....<br/>
	override public func getJSONValues() -> [String: Any] {<br/>
	return &#91;<br/>
	&#160;&#160;&#160;&#160;JSONDecoding.objectIdentifierKey: Profile.registerName,<br/>
	&#160;&#160;&#160;&#160;"username": username,<br/>
	&#160;&#160;&#160;&#160;"password": password,<br/>
	&#160;&#160;&#160;&#160;...<br/>
	&#160;&#160;&#160;&#160;&#93;<br/>
	....<br/>
	....<br/>
</blockquote>

Wichtig ist auch das die Objekt beim Start des Servers als JSONDecodable registriert werden müssen:

<blockquote>
	JSONDecoding.registerJSONDecodable(name: Profile.registerName, creator: {return Profile()})<br/>
</blockquote>

====Working Directory====
Beim setzen des Working Directory ist zu beachten, dass solange der Server nicht neu gestartet wird, nicht mehr im Verzeichnisbaum nach oben gändert werden kann, nur nach unten. Deshalb sollte das Working Direktory vom Standardwert Sources, nur maximal in ein Unterverzeichnis, wie bei unserem Server, dem Verzeichnis "exe", geändert werden. Beim Setzen des Working Directory wird der Ausführungsprozess in ein darunterliegendes Verzeichnis verschoben.

<blockquote>
	func setupDir(_: Void) -> Void {<br/>
	&#160;&#160;&#160;&#160;let workingDir = Dir("./Sources/exe")<br/>
	&#160;&#160;&#160;&#160;if workingDir.exists {<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;do {<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try workingDir.setAsWorkingDir()<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LogFile.debug("Working directory set to \(workingDir.name)")<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} catch {<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LogFile.debug("error in getFile() setting WorkingDir: \(error)")<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
	&#160;&#160;&#160;&#160;} else {<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LogFile.error("Directory \(workingDir.path) does not exist. Main executable not started from root of MVC cannot find resources?")<br/>
	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(2)<br/>
	&#160;&#160;&#160;&#160;}<br/>
	&#160;&#160;&#160;&#160;issetup = true<br/>
	}<br/>
	var issetup = false<br/>
</blockquote>

==JavaScript als Reverenz==

===JavaScript und Node.js===
Ursprünglich wurde JavaScript als Teil vom Webbrowsern implementiert um cleint-seitig Skripte auszuführen. Dabei soll dem Anwender eine Schnittstelle für interaktives Web geboten werden, asynchrone Anfragen und der Dokumenteninhalt verändert werden können. 
Die Sprache war in der Vergangenheit sehr negativ besetz und hat auch heute noch bei vielen einen negativen beigeschmack. Leider wird oft die Entwicklung von JavaScript in den lezten Jahren außer acht gelassen, wo sich JavaScript immer mehr Richtung "Unverzichtbarkeit" gearbeitet hat. Derzeit ist JavaScript beinahe auf jeder WebSite und Webanwendung vertretten. Früher als Spielzeug bezeichnet ist es heute ein beliebtes Werkzeug um dynamische WebSites zu erstellen und es Usern zu ermöglichen interaktiv im Browser und im Internet unterwegs zu sein. Auch große Firmen wie Mozilla, Google, Microsoft und Apple setzen mittlerweile auf JavaScript<ref name="t3n">{{Internetquelle|autor=Felix Gelsendörfer|jahr=2010|titel=Wie Node.js JavaScript auf dem Server revolutioniert: Schubrakete für JavaScript|url=http://t3n.de/magazin/nodejs-javascript-server-revolutioniert-schubrakete-226177/ |datum=2010-12-08 |zugriff=2017-07-27}} Gelsendörfer, Felix (2010): Wie Node.js JavaScript auf dem Server revolutioniert: Schubrakete für JavaScript, [online] http://t3n.de/magazin/nodejs-javascript-server-revolutioniert-schubrakete-226177/ [27.07.2017].</ref>. Mittlerweile ist die Sprache prototypenbasierte, dynamisch und typensicher ist. Grundlage für JavaScript bildet die Skriptsprache C sowie sehr viele Begriffsstandards von Java<ref name="SEOAnalyse">{{Internetquelle|autor=Fuchs Media Solutions|jahr=o.J.|titel=JavaScript Begriffserklärung und Definition|url=https://www.seo-analyse.com/seo-lexikon/j/javascript/ |datum=ohne Datum| zugriff=2017-07-27}} Fuchs Media Solutions (o.J.): JavaScript Begriffserklärung und Definition, [online] https://www.seo-analyse.com/seo-lexikon/j/javascript/ [27.07.2017].</ref>.
JavaScript am Server auszuführen ist seit Entstehung der Sprache eine laufende Idee von JavaScript Entwicklern und wurde bereits ein Jahr nach Entwicklung 1996 umgesetzt. Der Druchbruch gelang aber erst am 8. November 2009 als Ryan Dahl, Node.js vorstellte, dass bis heute immer beliebter wird. Mittlerweile gibt es sehr viele Tutorials, die es ermöglichen JavaScript und Node.js zu lernen und auch sehr viele Beispiel um sich diese Sprache und das Framework zu erlernen. 

=== Pros and Cons===

<table>
	<tr>
		<th>Pros of JavaScript</th>
		<th>Cons of JavaScript</th>
		<th>Pros of Node.js</th>
		<th>Cons of Node.js</th>
	</tr>
	<tr>
		<td>Benutzer freundlichere Websites</td>
		<td>JavaScript kann clientseitig deaktiviert werden</td>
		<td>Open source server Framework<ref name="w3schoolnodejs">{{Internetquelle|autor=Refnes Data|jahr=2017|titel=Node.js Introduction|url=https://www.w3schools.com/nodejs/nodejs_intro.asp |datum=ohne Datum |zugriff=2017-07-27}} Refnes Data (2017b): Node.js Introduction, [online] https://www.w3schools.com/nodejs/nodejs_intro.asp [27.07.2017].</ref></td>
		<td>Unübersichtlichkeit der Community und der Entwicklung, durch sehr schnelles Wachstum<ref name="codecentricde">{{Internetquelle|author=Gregor Elke|jahr=2014|title=Ist Node.js ein Superheld? [online]|url=https://blog.codecentric.de/2014/06/ist-node-js-ein-superheld/ |datum=2014-06-19|zugriff=2017-07-27}} Elke, Gregor (2014): Ist Node.js ein Superheld?, [online] https://blog.codecentric.de/2014/06/ist-node-js-ein-superheld/ [27.07.2017].</ref></td>
	</tr>
	<tr>
		<td>Dynamischer Inhalt von Websites</td>
		<td>Wenn deaktiviert, oft negative Auswirkungen</td>
		<td>lauffähig auf Windows, Linux, Unix, Mac OS X, ...<ref name="w3schoolnodejs"/></td>
		<td>Modulsytem verbraucht viel Speicher<ref name="codecentricde" /></td>
	</tr>
	<tr>
		<td>objekt-basiert, prototyping für Vererbung</td>
		<td>ursprünglich keine Vererbung</td>
		<td>Verwendung von serverseitigen JavaScript<ref name="codecentricde" /></td>
		<td>nur ein Prozess mit einem Speicher von 1,7 GB <ref name="codecentricde" /></td>
	</tr>
	<tr>
		<td>Objekt-Referenzen werden erst zur Laufzeit geprüft<ref name="MathematikUniUlm">{{Internetquelle|autor=o.V.|jahr=o.J.|titel=Gefahren und Anwendungsmöglichkeiten durch JavaScript|url=http://www.mathematik.uni-ulm.de/sai/ws01/portalsem/wiede/ |datum=ohne Datum|zugriff=2017-07-27}} o.V. (o.J.): Gefahren und Anwendungsmöglichkeiten druch JavaScript, [online], http://www.mathematik.uni-ulm.de/sai/ws01/portalsem/wiede/ [27.07.2017].</ref></td>
		<td>schwach typisierte Variablen<ref name="MathematikUniUlm"/></td>
		<td>Asynchron, event basiert<ref name="codecentricde" /></td>
		<td>benötigt cluster um große Mengen abzuarbeiten<ref name="codecentricde" /></td>
	</tr>
	<tr>
		<td>einfache prozeduale Sprache<ref name="MathematikUniUlm"/></td>
		<td>kein natives Modulsystem<ref name="codecentricde" /></td>
		<td>einbinden von C und C++ libraries<ref name="codecentricde" /></td>
		<td>nicht alle libraries von C und C++ verfügbar<ref name="codecentricde" /></td>
	</tr>
</table>

===ECMAScript===

JavaScript wurde in der <span class = "plainlinks">[http://www.ecma-international.org/ ECMA]</span> (European association for standardizing information and communication systems) spezifiziert. Der Name "ECMAScript" wurde deshalb gewählt weil Netscape und Microsoft sich nicht auf einen gemeinsamen Namen für die eigenständigen Sprachen "JScript und JavaScript" einigen konnten. Jedoch wurde dieser Name nie weitläufig zur Gewohnheit weil Brendan Eich, Erfinder von JavaScript meinte, dass dies "wie eine Hautkrankheit" klinge<ref name="Schrödinger lernt HTML5, CSS3 & JavaScript">{{cite book|author=Kai Günster|jahr=2013|title=Schrödinger lernt HTML5, CSS3 & JavaScript|isbn=978-3-8362-2020-0|publisher=Galileo Computing|zugriff=2017-07-27}} Günster, Kai (2013): ''Schrödinger lernt HTML5, CSS3 & JavaScript: das etwas andere Fachbuch'', Bonn: Galileo Press.</ref>. Entwickler können die offene Sprache zum Entwickeln von Programmen nutzen und dabei sicher gehen, dass der Code unterstützt wird, wenn dieser den Standard einhält. 

=== Swift vs. JavaScript=== 

====Ziel der Entwicklung====
Einen großen Unterschied bei den beiden Sprachen liegt im Ziel der Entwicklung der Sprachen. JavaScript wurde entwickelt mit dem Ziel, statisches HTML und CSS im Web, dynamischer zu gestallten und dem Client ein interaktives Web zu bietet. JavaScript ist beinahe auf jeder Website zu finden und auch nicht mehr wegzudenken<ref name="devMozilla">{{Internetquelle|autor=Mozilla Developer and individual contributors |jahr=2017|titel=JavaScript Guide - Introduction|url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction |datum=2017-05-25|zugriff=2017-07-27}}
Mozilla Developer Network and individual contributors (2017): JavaScript Guide - Introduction, [online] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction [27.07.2017].</ref>.
Hingegen zu JavaScript ist Swift als eine Allzwecksprache erfunden worden, mit der Absicht die beste, einheitliche Sprache für die Systemprogrammierung, zu mobilen Applikationen und Desktop Anwendungen, bis hin zum Cloud Service zu bieten. Dabei wurde noch auf drei Punkte sehr großen Wert gelegt<ref name="SwiftAbout">{{Internetquelle |autor=Apple Inc |jahr=2017a|titel=About Swift [online]|url=https://swift.org/about/ |datum=ohne Veröffentlichunsdatum|zugriff=2017-07-27}} Apple Inc (2017a): About Swift, [online] https://swift.org/about/ [27.07.2017].</ref>:
* Sicherheit: Dabei wird davon ausgegengen das nicht definiertes Verhalten der Grund für unsichere Programmierung ist. So muss in Swift jedes mögliche Ende bedacht und definiert werden da sonnst eine Kompiliertungsfehler auftritt.
* Performance: Swift soll alle C-basierten Sprachen ersetzen. Dazu muss Swift vergleichbar in der Abarbeitung verschiedener Aufgaben sein wie diese Sprachen und diese genau so schnell umsetzen können und gleichzeitig die Ressourcen schonen.
* Ausdruck: Die Syntax<ref name="SwiftLang">{{Internetquelle|autor=Apple Inc|jahr=2017b|titel=Language Guide|url=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309 |datum=05-06-2017 |zugriff=2017-07-27}} Apple Inc (2017b): Swift - Language Guide, [online] https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309 [27.07.2017].</ref> wurde mit Jahrzenten von Programmiererfahrung entwicklet und wird auch immer weiter entwicklt werden. 

====Compiling====
Da JavaScript eine dynamische Typisierte, prototypenbasierte, interpretierte Programmiersprache ist, wobei die Betonung auf "interpretierte" liegt. Der Unterschied liegt darin, dass Swift zu den kompilierten Sprachen zählt.

''''Interpretiert Sprachen:''''

In dem Moment wo das Programm gestartet wird, wird der Code in Insturktionen übersetzt und auch ausgeführt. Diese Übersetzung übernimmt ein zusätliches Tool, der Interpreter. Dieser läuft wie eine virtuelle Maschine auf dem PC und nimmt Eingaben sowie den Quellcode und wandelt diesen in einen Hardwareunabhängigen Bytecode. Dies passiert während der Laufzeit wobei pro Porzessor ein Interpreter benötigt wird. 
'''Vorteil:''' Leichter bei der Entwicklung, da bereits während der Entwicklung getestet werden kann. JavaScript wird im Plaintext an den Client übertragen und kann von anderen Entwicklern gelesen und gelernt werden.
'''Nachteil:''' Langsamer und ineffizinter als kompilierte Sprachen, da Kontrollflusssteuernte Funktionen (Schleifen, Funktionen) immer wieder übersetzt werden müssen. <ref name="ElektronikKompendium">{{Internetquelle |autor=Patrick Schnabel |jahr=2012 |titel=Compiler und Interpreter [online] |url=https://www.elektronik-kompendium.de/sites/com/1705231.htm |datum=2012-11-28 |zugriff=2017-07-27 }}
Schnabel, Patrick (2012): Compiler und Interpreter, [online] https://www.elektronik-kompendium.de/sites/com/1705231.htm [27.07.2017].</ref>

''''Kompilierte Sprachen:''''
Der Compiler übersetz den Quellcode in ein maschinenlesbares Programm sodass, es vom Menschen nicht mehr gelesen werden kann jedoch sofort ausgeführt werden kann. Dieses Porgramm bzw. die Anweisungen im Programm werden direkt vom Prozessor ausgeführt. Jedesmal wenn sich im Programmcode etwas ändert, muss der gesamte Code neue kompiliert werden.
'''Vorteil:''' Der Code wird durch den Compiler optimiert. Kompilierte Programme sind sehr schnell in der Ausführung.
'''Nachteil:''' Der Aufwand bei der Entwicklung ist ist zeitraubender, da das Programm vor einem Testlauf jedesmal neu kompiliert werden muss. <ref name="ElektronikKompendium" />

===Warum JavaScript mit Node.js als Reverenz===

JavaScript hat mit dem immer aufsteigenden Interesse und der schnellen Weiterentwicklung einen sehr interessanten Höhenflug. Auch wird es in der Webentwicklung serverseitig immer öfters eingesetz. Damit kann man neben PHP davon ausgehen das JavaScript mit Frameworks wie Node.js eine solide Basis für einen Vergleich bietet. Da Swift auch unter anderem die beste Sprache für die Webentwicklung werden möchte, kann somit ein Fazit gezogen werden, in wie weit Swift dieses Ziel bereits erreicht hat und in welchen Bereichen noch nachholbedarf besteht. 

===Installation des Node.js Servers===

Der Server ist wie bereits bei der Installation des Swift-Servers von Github auszuchecken oder als .zip-Datei herunterzuladen. Nach dem auschecken oder entpacken des Projekts, muss mit einem Terminal ins Verzeichnis "NodeServer" gewechselt werden und der Server mit npm initalisiert werden. Dabei werden alle notwendigen Packages heruntergeladen und der Server kann mit node gestartet werden. 

<blockquote>
	<code>cd NodeServer</code><br/>
	<code>npm init</code><br/>
	<code>node index.js</code><br/>
</blockquote>

===Die Server im Vergleich===

Beide Server sind im MVC (Model View Controller) Pattern gehalten und haben folgenden Ablauf:
Request wird empfangen und an einen den jeweiligen Handler weitergegeben.
Handler geben entweder den Request direkt an eine View-Klasse/Methode oder an eine Model-Klasse/Methode weiter.
Die Model Dateien speichern User-Daten wie Usernamen, Passwort, Vorname, Nachname und E-Mail in einem JSON File. Das Passwort wird bevor es gespeichert wird verschlüsselt.
Die Profile der User werden in beide Servern als eigenen Objekt angelegt und können als JSON serialisiert werden. Als Sammelverzeichnis wird der Ordner "profiles" angelegt in dem wiederum ein Verzeichnis mit dem Usernamen in dem das JSON File gespeichert wird. Diese Verzeichnisse sind notwenig sollten Bilder oder ähnlichen zu den Usern gespeichert werden.
Als zweite Funktion sind in den Model Dateien Funktionen enthalten, die diese Daten aus den JSON Files wieder ausliest, und das Passwort z.B. für den Login überprüfen. 
Spätestens nachdem die Model-Funktionen fertig sind wird der Request an die View übergeben und werden hier in HTML aufbereitet und an den Client zurückgeschickt.
Die Funktionalität ist für Studenten der FH Joanneum gedacht und können die tätsächlichen Noten mit dem Usernamen und Passwort der FH-Domain abrufen. 
Die Server unterscheiden sich ausschließlich durch Sprach- und Framework spezifischen Vorgaben wie z.B. eine Funktion die in Express vorhanden ist jedoch in Perfect nicht und umgekehrt.
Weiter haben wir versucht ähnliche Packages zu verwenden und so wenig Workaround zu verwenden, die Packages ersetzen.

==Conclusion==
Mit dem Ziel die beste Sprache der Entwicklung zu werden, hat sich Swift ein sehr hohes Ziel gesteckt, dass beinahe nicht zu erreichen sein wird. Bei der Entwicklung des Swift Servers sind einige Probleme aufgetaucht, die wir hier in unserer subjektiven Meinung beschreiben möchten.

===Die Sprache===
Unter anderem ist uns aufgefallen, dass die Syntax anfangs ungewohnt ist und etwas Zeit in Anspruch nimmt, sich mit dieser Vertraut zu machen. Die Dokumentation bzw. die Guides die auf Swift.org oder auch auf anderen Seiten zur Verfügung gestellt werden, sind eine Unterstützung, jedoch kommt man leider nicht darum herum, sehr vieles mit "try and error" auszutesten. Sehr hilfreich war der auf Apples Developer Seite zu findente <span class = "plainlinks">[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309 Language Guide]</span> welcher die Basics und auch viele fortgeschrittene Themen behandelt. Für Kontrollfluss-Funktionen gibt es die Möglichkeit z.B. Initaliseriung, Condition-Überprüfung und "else"-Block in eine Zeile zu schreiben. Leider wird der Code dadurch schwer lesbar und für Entwickler anderer Sprachen beinahe unmöglich lesbar, sollte keine Zeit zum Investieren vorhanden sein.

===Das Framework===
Zum verwendeten Framwork ist zu sagen, dass es bereits sehr gute Ansetze für die Abhandlung von Request und Response bereithält, jedoch noch einen sehr weiten Weg zum Referenzprodukt Node.js hat. Das Handling im allgemeinen ist sehr unsausgereift und muss mit vielen kleinen Workarounds dazu gebracht werden, das Verhalten von Node.js zu imitieren. Leider verführt das vorgeschlagene Requesthandling dazu, dass viele Methoden angelegt werden die alle das gleiche Verhalten aufweisen, jedoch auch nur schwerliche refactored werden können. 
Leider gab es für Perfect auch keinen Beispiel-Server mit mehrern Seiten und Funktionen, der veranschaulicht wie die Entwickler des Frameworks sich die Umsetzung bzw. die Verwendung des Frameworks gedacht haben. Bei den vorhanden Beispielen war oft die Dokumentation unzureichen, sodass die Anwendung verschiedern Packages in der begrenzten Zeit nicht möglich waren. Als Beispiel lässt sich das Perfect-Crypto Package anführen wo die Beschreibung nicht reichte, um ein Passwort zu verschlüsseln. Dazu wurde von uns das Packet SwiftyBeaver nach längerem studieren der Klassen und Methoden von Perfect-Crypte als Ersatz verwendet. Einigemale mussten die Packages selbst analysiert werden, um zu verstehen, wie die Pakete angewand werden, was natürlich wiederum zu einen besseren Verständnis führte, jedoch eine Menge Zeit verschlang.
Grundsätlich ist das Framework weiter zu empfählen, jedoch muss bis zum Sicheren anwenden des Frameworks sehr viel Zeit und Ärger investiert werden. 

Abschließend bleibt noch zu sagen, dass diese Sprache für sich genommen eine sehr schöne und lesbare Sprache ist, wenn nur wenige Kurzschreibweisen verwendet werden. Der Ansatz der Sicherheit und der daraus schließenden "absoluten Definition" ist nachvollziebar und auch sehr vorteilhaft, da man bei jeder Methode und Funktion das Verhalten genau erkennt. Jedoch ist es bis zum Einholen des Node.js Frameworks noch viel Arbeit, da das Node.js Framework ausgereifter und mehr Funktionen in Form von Modulen bietet. Leider ist Perfect für die Version 3.0 entwickelt worden, der Server bereits auf 3.1 entwickelt, und während der Entwicklung Version 4.0 von Swift veröffentlich worden, wodurch sich Fehler in der Dokumentation eingeschlichen haben.

==Einzelnachweise==

<references/>
